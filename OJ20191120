#include <stdio.h>
#include <stdlib.h>
typedef struct Node{    
	char data;    
	Node *Lchild, *Rchild;
} BiTNode, *BiTree; 
BiTree CreateBiTree() {  // 建立二叉树  
	char x;    
	BiTree T;    
	scanf("%c",&x);    
	if(x == '#')        
		T = NULL;    
	else {        
		T = (BiTree)malloc(sizeof(BiTNode));       
		T->data = x;        
		T->Lchild = CreateBiTree();        
		T->Rchild = CreateBiTree();    
	}    
	return T;
} 
BiTree Find(BiTree T, char x) {    
	BiTNode *p;    
	if(T == NULL)        
		return NULL;    
	else if(T->data == x)        
		return T;    
	else if(T->Lchild != NULL && T->Lchild->data == x) {        
		p = T->Lchild;        
		T->Lchild = NULL;        
		return p;    
	}    
	else if(T->Rchild != NULL && T->Rchild->data == x) {        
		p = T->Rchild;        
		T->Rchild = NULL;        
		return p;    
	}    
	else {        
		p = Find(T->Lchild, x);        
		if(p != NULL)            
			return p;        
		else            
			return Find(T->Rchild, x);    
	}
} 
void PreOrder(BiTree T) {   // 先序 
	if(T != NULL) {        
		printf("%c ", T->data);        
		PreOrder(T->Lchild);        
		PreOrder(T->Rchild);    
	}
}
void Destory(BiTree T) {    
	if(T != NULL) {        
		Destory(T->Lchild);        
		Destory(T->Rchild);        
		free(T);    
	}
} 
BiTree Delete(BiTree T, char x) {    
	BiTNode *p = Find(T, x);    
	if(p != NULL)        
		Destory(p);
	return T;
}
int main(){
	int n;
	char x;
	BiTree T;
	while (scanf("%d", &n) != EOF) {
		while (n--) {
			BiTree root = CreateBiTree();
			getchar(); 
			scanf("%c", &x);
			T = Delete(root, x);
			if(!T)
				printf("empty");
			else
				PreOrder(root);
			printf("\n");
			getchar(); 
		}
	}
	return 0;
}

#include <stdio.h>
#include <stdlib.h>
struct Btree{    
	int x;    
	Btree *left;    
	Btree *right;    
	Btree() {        
		left = NULL;        
		right = NULL;    
	}
};
typedef struct Btree Btree;
Btree *root;
int n;
int vis[10000]; 
void Insert(Btree *&r, int x){    
	if(r == NULL) {        
		r = new Btree;        
		r->x = x;    
	}    
	else {        
		if(x < r->x)
			Insert(r->left, x);             
		else
			Insert(r->right, x);        
	}
}
void preorder(Btree* root) {  // 输出先序序列
	if (root) {
		printf("%d ", root->x);
		preorder(root->left);
		preorder(root->right);
	}
}
void inorder(Btree* root) {  // 输出中序序列
	if (root) {
		inorder(root->left);
		printf("%d ", root->x);
		inorder(root->right);
	}
}
void postorder(Btree* root) {  // 输出后序序列
	if (root) {
		postorder(root->left);
		postorder(root->right);
		printf("%d ", root->x);
	}
}
int Find(int x, Btree *r){    
	if(r == NULL) 
		return 0;      
	else {        
		if(r->x == x)
			return 1;
		else {            
			int left = Find(x, r->left);            
			int right = Find(x, r->right);            
			return left + right;        
		}    
	}
}
int main(){
	int n, x;
	scanf("%d", &n);
	root = NULL;
	for (int i = 0; i < n; i++) {
		scanf("%d",&x);  
        if(Find(x, root) == 0)
			Insert(root, x);  
	}
	preorder(root);
	printf("\n");
	inorder(root);
	printf("\n");
	postorder(root);
	printf("\n");
	return 0;
}
