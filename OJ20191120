#include <stdio.h>
#include <stdlib.h>
typedef struct Node{    
	char data;    
	Node *Lchild, *Rchild;
} BiTNode, *BiTree; 
BiTree CreateBiTree() {  // 建立二叉树  
	char x;    
	BiTree T;    
	scanf("%c",&x);    
	if(x == '#')        
		T = NULL;    
	else {        
		T = (BiTree)malloc(sizeof(BiTNode));       
		T->data = x;        
		T->Lchild = CreateBiTree();        
		T->Rchild = CreateBiTree();    
	}    
	return T;
} 
BiTree Find(BiTree T, char x) {    
	BiTNode *p;    
	if(T == NULL)        
		return NULL;    
	else if(T->data == x)        
		return T;    
	else if(T->Lchild != NULL && T->Lchild->data == x) {        
		p = T->Lchild;        
		T->Lchild = NULL;        
		return p;    
	}    
	else if(T->Rchild != NULL && T->Rchild->data == x) {        
		p = T->Rchild;        
		T->Rchild = NULL;        
		return p;    
	}    
	else {        
		p = Find(T->Lchild, x);        
		if(p != NULL)            
			return p;        
		else            
			return Find(T->Rchild, x);    
	}
} 
void PreOrder(BiTree T) {   // 先序 
	if(T != NULL) {        
		printf("%c ", T->data);        
		PreOrder(T->Lchild);        
		PreOrder(T->Rchild);    
	}
}
void Destory(BiTree T) {    
	if(T != NULL) {        
		Destory(T->Lchild);        
		Destory(T->Rchild);        
		free(T);    
	}
} 
BiTree Delete(BiTree T, char x) {    
	BiTNode *p = Find(T, x);    
	if(p != NULL)        
		Destory(p);
	return T;
}
int main(){
	int n;
	char x;
	BiTree T;
	while (scanf("%d", &n) != EOF) {
		while (n--) {
			BiTree root = CreateBiTree();
			getchar(); 
			scanf("%c", &x);
			T = Delete(root, x);
			if(!T)
				printf("empty");
			else
				PreOrder(root);
			printf("\n");
			getchar(); 
		}
	}
	return 0;
}

#include <stdio.h>
#include <stdlib.h>
typedef struct TreeNode{
	int data;
	struct TreeNode *lchild;
	struct TreeNode *rchild;
}TreeNode, *ptr;
ptr N;
int i = 0;
void preorder(ptr N){
	if(N != NULL){
		printf("%d ", N->data);
		preorder(N->lchild);
		preorder(N->rchild);
	}
}
void inorder(ptr N){
	if(N != NULL){
		inorder(N->lchild);
		printf("%d ", N->data);
		inorder(N->rchild);
	}
}
void postorder(ptr N){
	if(N != NULL){
		postorder(N->lchild);
		postorder(N->rchild);
		printf("%d ", N->data);
	}
}
ptr InsertN(ptr N, int x){
	ptr Node = (ptr)malloc(sizeof(N));
	Node->data = x;
	Node->lchild = Node->rchild = NULL;
	if(N == NULL)
		N = Node;
	if(N->lchild == NULL && N->data > x)  // 插入到当前结点N的左孩子
        N->lchild = Node;
    if(N->rchild == NULL && N->data < x)  // 插入到当前结点N的右孩子  
        N->rchild = Node;
	if(N->data > x)
		InsertN(N->lchild, x);
	else if(N->data < x)
		InsertN(N->rchild, x);	
	return N;
}
int main(){
	int n;
	scanf("%d", &n);
	ptr T = NULL;
	for(int i = 0; i < n; i++){
		int x;
		scanf("%d", &x);
		T = InsertN(T, x);
	}
	preorder(T);
	printf("\n");
	inorder(T);
	printf("\n");
	postorder(T);
	printf("\n");
	return 0;
}
