#include<stdio.h>
#include<stdlib.h>
#include<string.h>
char s1[1000];
char s2[1000];
typedef struct TreeNode {
	char data;
	struct TreeNode *leftchild, *rightchild;
}TreeNode, *ptr;
void CreateTree(int a1, int b1, int a2, int b2) {  // 根据中序和层次遍历建二叉树
	ptr bt;
	bt = (ptr)malloc(sizeof(TreeNode));
	int i, j;
	for (i = a2; i <= b2; i++) {
		int flag = 0;
		for (j = a1; j <= b1; j++) {
			if (s2[i] == s1[j]) {    // 输出根节点
				bt->data = s2[i];
				printf("%c", bt->data);
				flag = 1;
				break;
			}
		}
		if (flag)
			break;
	}
	if(j > a1)  // 遍历左子树
        CreateTree(a1,j-1,0,b2); 
    if(j < b1)  // 遍历右子树 
        CreateTree(j+1,b1,0,b2);
}
int main() {
	scanf("%s", &s1);
	scanf("%s", &s2);
	CreateTree(0, strlen(s1) - 1, 0, strlen(s2));
	return 0;
}

#include <stdio.h>
#include <stdlib.h>
typedef struct ArcNode {
    int adjvex;   // 有向边的另一个邻接点的序号
	int weight;   // 边的权值
    struct ArcNode *nextarc;   // 指向下一个边结点的指针
}ArcNode, *arc;
typedef struct VNode {   // 顶点
    int data; 
    struct ArcNode *head1;   // 出边表的表头指针
    struct ArcNode *head2;   // 入边表的表头指针
}VNode;
typedef struct LGraph {   // 图的邻接表存储结构
    struct VNode vertexs[10];   // 顶点数组
    int vexnum, arcnum;         // 顶点数和边数
}LGraph;
LGraph lg;   // 图
void CreateLG(){
    int i;
    arc pi;   // 用来构造边链表的边结点指针
    int u, v, w;   // 有向边的两个顶点和权值
    for(i = 0; i < lg.vexnum; i++)   // 初始化表头指针为空    
        lg.vertexs[i].head1 = lg.vertexs[i].head2 = NULL;
    for(i = 0; i < lg.arcnum; i++) {
        scanf("%d %d %d", &u, &v, &w);   // 输入一条边的起点、终点和权值
        pi = (arc)malloc(sizeof(ArcNode));
        pi->adjvex = v;
		pi->weight = w;
        pi->nextarc = lg.vertexs[u].head1;   // 插入链表
        lg.vertexs[u].head1 = pi;
        pi = (arc)malloc(sizeof(ArcNode));
        pi->adjvex = u;
        pi->nextarc = lg.vertexs[v].head2;   // 插入链表
        lg.vertexs[v].head2 = pi;
    }
}
void DeleteLG() {   // 释放图G的存储空间
    int i;
    arc pi;    // 用来指向边链表中各边结点的指针
    for(i = 0; i < lg.vexnum; i++) {
        pi = lg.vertexs[i].head1;       
        while(pi != NULL) {   // 释放第i个顶点出边表的存储空间
            lg.vertexs[i].head1 = pi->nextarc;
            free(pi);
            pi = lg.vertexs[i].head1;
        }        
        pi = lg.vertexs[i].head2;
        while(pi != NULL) {   // 释放第i个顶点入边表的存储空间
            lg.vertexs[i].head2 = pi->nextarc;
            free(pi);
            pi = lg.vertexs[i].head2;
        }
    }
}
int main(){
    int i;
    int ind[10], outd[10];   // 顶点的入度和出度
    arc pi;   // 用来遍历链表的边结点指针
    scanf("%d %d", &lg.vexnum, &lg.arcnum);
    CreateLG();
    for(i = 0; i < lg.vexnum; i++) {   // 统计顶点的出度
		outd[i] = 0;
        pi = lg.vertexs[i].head1;
        while(pi != NULL){
			outd[i]++;
            pi = pi->nextarc;
        }
	}
    for(i = 0; i < lg.vexnum; i++){   // 统计顶点的入度
        ind[i] = 0;
        pi = lg.vertexs[i].head2;
        while(pi != NULL){
            ind[i]++;
            pi = pi->nextarc;
        }
    }
	for(i = 0; i < lg.vexnum; i++){
		printf("%d %d %d\n", i, outd[i], ind[i]);
	}
    DeleteLG();
    return 0;
}
